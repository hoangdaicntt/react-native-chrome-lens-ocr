import { imageDimensionsFromData } from 'image-dimensions';
import setCookie from 'set-cookie-parser';
import { createRequire } from 'module';
import { LENS_API_KEY, LENS_PROTO_ENDPOINT, EXT_TO_MIME, SUPPORTED_MIMES } from './consts.js';
import { parseCookies } from './utils.js';
import type {
    BoundingBoxPixelCoords,
    CookieDetail,
    CookieStore,
    FetchFunction,
    LensInitOptions,
    LensResolvedConfig,
    SupportedMime
} from './types.js';

const require = createRequire(import.meta.url);

// Proto buffers generated by the original project, loaded via CommonJS.
// eslint-disable-next-line @typescript-eslint/no-var-requires
const { LensOverlayServerRequest, LensOverlayObjectsRequest, LensOverlayRequestContext, LensOverlayServerResponse, LensOverlayServerError, LensOverlayServerErrorErrorType } = require('./utils/proto_generated/lens_overlay_server_pb.cjs');
// eslint-disable-next-line @typescript-eslint/no-var-requires
const { LensOverlayClientContext, LocaleContext } = require('./utils/proto_generated/lens_overlay_client_context_pb.cjs');
// eslint-disable-next-line @typescript-eslint/no-var-requires
const { Platform, Surface } = require('./utils/proto_generated/lens_overlay_client_platform_pb.cjs');
// eslint-disable-next-line @typescript-eslint/no-var-requires
const { ImageData, ImagePayload, ImageMetadata } = require('./utils/proto_generated/lens_overlay_image_data_pb.cjs');
// eslint-disable-next-line @typescript-eslint/no-var-requires
const { LensOverlayRequestId } = require('./utils/proto_generated/lens_overlay_request_id_pb.cjs');
// eslint-disable-next-line @typescript-eslint/no-var-requires
const { AppliedFilter, AppliedFilters, LensOverlayFilterType } = require('./utils/proto_generated/lens_overlay_filters_pb.cjs');
// eslint-disable-next-line @typescript-eslint/no-var-requires
const { CoordinateType } = require('./utils/proto_generated/lens_overlay_geometry_pb.cjs');

type NormalisedBoundingBox = [number, number, number, number];

export class BoundingBox {
    #imageDimensions: [number, number];
    public centerPerX: number;
    public centerPerY: number;
    public perWidth: number;
    public perHeight: number;
    public pixelCoords: BoundingBoxPixelCoords;

    constructor(box: NormalisedBoundingBox, imageDimensions: [number, number]) {
        if (!box || box.length !== 4) {
            throw new Error('Bounding box array [centerPerX, centerPerY, perWidth, perHeight] not set or invalid');
        }

        if (!imageDimensions || imageDimensions.length !== 2) {
            throw new Error('Image dimensions [width, height] not set or invalid');
        }

        this.#imageDimensions = imageDimensions;

        this.centerPerX = box[0];
        this.centerPerY = box[1];
        this.perWidth = box[2];
        this.perHeight = box[3];
        this.pixelCoords = this.#toPixelCoords();
    }

    #toPixelCoords(): BoundingBoxPixelCoords {
        const [imgWidth, imgHeight] = this.#imageDimensions;

        const width = this.perWidth * imgWidth;
        const height = this.perHeight * imgHeight;

        const x = (this.centerPerX * imgWidth) - (width / 2);
        const y = (this.centerPerY * imgHeight) - (height / 2);

        return {
            x: Math.round(x),
            y: Math.round(y),
            width: Math.round(width),
            height: Math.round(height)
        };
    }
}

export class LensError extends Error {
    public code: string;
    public headers: Headers;
    public body: string;

    constructor(message: string, code: string, headers: Headers, body: string) {
        super(message);
        this.name = 'LensError';
        this.code = code;
        this.headers = headers;
        this.body = body;
    }
}

export class Segment {
    constructor(
        public text: string,
        public boundingBox: BoundingBox
    ) {}
}

export class LensResult {
    constructor(
        public language: string,
        public segments: Segment[]
    ) {}
}

type HeaderInput = Record<string, string | undefined>;

function normaliseHeaders(headers?: HeaderInput): Record<string, string> {
    if (!headers) {
        return {};
    }

    const normalised: Record<string, string> = {};
    for (const [rawKey, value] of Object.entries(headers)) {
        if (!value) {
            continue;
        }

        const key = rawKey.toLowerCase();
        normalised[key] = value;
    }

    return normalised;
}

export default class LensCore {
    #config: LensResolvedConfig;
    public cookies: CookieStore = {};
    protected _fetch: FetchFunction;

    constructor(config: LensInitOptions = {}, fetchFn?: FetchFunction) {
        if (config && typeof config !== 'object') {
            throw new TypeError('Lens constructor expects an object');
        }

        const globalFetch = globalThis.fetch?.bind(globalThis);
        if (fetchFn) {
            this._fetch = fetchFn;
        } else if (globalFetch) {
            this._fetch = globalFetch;
        } else {
            throw new Error('Global fetch is not available in this environment');
        }

        const chromeVersion = config.chromeVersion ?? '124.0.6367.60';
        const majorChromeVersion = config.majorChromeVersion ?? chromeVersion.split('.')[0] ?? '124';

        const headers = normaliseHeaders(config.headers);

        this.#config = {
            chromeVersion,
            majorChromeVersion,
            userAgent: config.userAgent ?? `Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/${majorChromeVersion}.0.0.0 Safari/537.36`,
            endpoint: config.endpoint ?? LENS_PROTO_ENDPOINT,
            viewport: config.viewport ?? [1920, 1080],
            headers,
            fetchOptions: config.fetchOptions ? { ...config.fetchOptions } : {},
            targetLanguage: config.targetLanguage ?? 'en',
            region: config.region,
            timeZone: config.timeZone
        };

        this.#parseCookies();
    }

    updateOptions(options: LensInitOptions = {}): void {
        if (options.chromeVersion) {
            this.#config.chromeVersion = options.chromeVersion;
            if (!options.majorChromeVersion) {
                this.#config.majorChromeVersion = options.chromeVersion.split('.')[0] ?? this.#config.majorChromeVersion;
            }
        }

        if (options.majorChromeVersion) {
            this.#config.majorChromeVersion = options.majorChromeVersion;
        }

        if (options.userAgent) {
            this.#config.userAgent = options.userAgent;
        }

        if (options.endpoint) {
            this.#config.endpoint = options.endpoint;
        }

        if (options.viewport) {
            this.#config.viewport = options.viewport;
        }

        if (options.targetLanguage) {
            this.#config.targetLanguage = options.targetLanguage;
        }

        if (options.region !== undefined) {
            this.#config.region = options.region;
        }

        if (options.timeZone !== undefined) {
            this.#config.timeZone = options.timeZone;
        }

        if (options.headers) {
            for (const [rawKey, value] of Object.entries(options.headers)) {
                const key = rawKey.toLowerCase();
                if (!value) {
                    delete this.#config.headers[key];
                } else {
                    this.#config.headers[key] = value;
                }
            }
        }

        if (options.fetchOptions) {
            this.#config.fetchOptions = {
                ...this.#config.fetchOptions,
                ...options.fetchOptions
            };
        }

        this.#parseCookies();
    }

    #createLensProtoRequest(imageBytesUint8Array: Uint8Array, width: number, height: number): Uint8Array {
        const targetLanguage = this.#config.targetLanguage;

        const requestId = new LensOverlayRequestId();
        requestId.setUuid(String(Date.now()) + String(Math.floor(Math.random() * 1_000_000)));
        requestId.setSequenceId(1);
        requestId.setImageSequenceId(1);

        const localeContext = new LocaleContext();
        localeContext.setLanguage(targetLanguage);
        localeContext.setRegion(this.#config.region || 'US');
        localeContext.setTimeZone(this.#config.timeZone || 'America/New_York');

        const appliedFilter = new AppliedFilter();
        appliedFilter.setFilterType(LensOverlayFilterType.AUTO_FILTER);
        const clientFilters = new AppliedFilters();
        clientFilters.addFilter(appliedFilter);

        const clientContext = new LensOverlayClientContext();
        clientContext.setPlatform(Platform.WEB);
        clientContext.setSurface(Surface.CHROMIUM);
        clientContext.setLocaleContext(localeContext);
        clientContext.setClientFilters(clientFilters);

        const requestContext = new LensOverlayRequestContext();
        requestContext.setRequestId(requestId);
        requestContext.setClientContext(clientContext);

        const imageMetadata = new ImageMetadata();
        imageMetadata.setWidth(width);
        imageMetadata.setHeight(height);

        const imagePayload = new ImagePayload();
        imagePayload.setImageBytes(imageBytesUint8Array);

        const imageData = new ImageData();
        imageData.setPayload(imagePayload);
        imageData.setImageMetadata(imageMetadata);

        const objectsRequest = new LensOverlayObjectsRequest();
        objectsRequest.setRequestContext(requestContext);
        objectsRequest.setImageData(imageData);

        const serverRequest = new LensOverlayServerRequest();
        serverRequest.setObjectsRequest(objectsRequest);

        return serverRequest.serializeBinary();
    }

    #parseLensProtoResponse(serverResponseProto: any, originalImageDimensions: [number, number]): LensResult {
        if (serverResponseProto.hasError()) {
            const errorProto = serverResponseProto.getError();
            const errorTypeName = Object.keys(LensOverlayServerErrorErrorType).find(
                key => LensOverlayServerErrorErrorType[key as keyof typeof LensOverlayServerErrorErrorType] === errorProto.getErrorType()
            );
            console.warn(`Lens server returned error: Type=${errorProto.getErrorType()} (${errorTypeName ?? 'UNKNOWN'})`);
            if (errorProto.getErrorType() !== LensOverlayServerErrorErrorType.UNKNOWN_TYPE) {
                return new LensResult('', []);
            }
        }

        if (!serverResponseProto.hasObjectsResponse()) {
            return new LensResult('', []);
        }
        const objectsResponse = serverResponseProto.getObjectsResponse();

        if (!objectsResponse.hasText() || !objectsResponse.getText().hasTextLayout()) {
            return new LensResult('', []);
        }

        const textProto = objectsResponse.getText();
        const textLayout = textProto.getTextLayout();
        const detectedLanguage = textProto.getContentLanguage()
            || textLayout.getParagraphsList()[0]?.getContentLanguage()
            || '';

        const segments: Segment[] = [];

        for (const paragraph of textLayout.getParagraphsList()) {
            for (const line of paragraph.getLinesList()) {
                let lineTextContent = '';
                const wordsList = line.getWordsList();
                for (let i = 0; i < wordsList.length; i++) {
                    const word = wordsList[i];
                    lineTextContent += word.getPlainText();
                    if (word.hasTextSeparator()) {
                        lineTextContent += word.getTextSeparator();
                    } else if (i < wordsList.length - 1) {
                        lineTextContent += ' ';
                    }
                }
                lineTextContent = lineTextContent.replace(/\s+/g, ' ').trim();

                if (lineTextContent) {
                    let boundingBox: BoundingBox | null = null;
                    if (line.hasGeometry() && line.getGeometry().hasBoundingBox()) {
                        const protoGeoBox = line.getGeometry().getBoundingBox();
                        if (protoGeoBox.getCoordinateType() === CoordinateType.NORMALIZED) {
                            const boxData: NormalisedBoundingBox = [
                                protoGeoBox.getCenterX(),
                                protoGeoBox.getCenterY(),
                                protoGeoBox.getWidth(),
                                protoGeoBox.getHeight()
                            ];
                            boundingBox = new BoundingBox(boxData, originalImageDimensions);
                        }
                    }

                    if (!boundingBox && paragraph.hasGeometry() && paragraph.getGeometry().hasBoundingBox()) {
                        const protoGeoBox = paragraph.getGeometry().getBoundingBox();
                        if (protoGeoBox.getCoordinateType() === CoordinateType.NORMALIZED) {
                            const boxData: NormalisedBoundingBox = [
                                protoGeoBox.getCenterX(),
                                protoGeoBox.getCenterY(),
                                protoGeoBox.getWidth(),
                                protoGeoBox.getHeight()
                            ];
                            boundingBox = new BoundingBox(boxData, originalImageDimensions);
                        }
                    }

                    if (!boundingBox) {
                        boundingBox = new BoundingBox([0.5, 0.5, 1, 1], originalImageDimensions);
                    }
                    segments.push(new Segment(lineTextContent, boundingBox));
                }
            }
        }
        return new LensResult(detectedLanguage, segments);
    }

    async #sendProtoRequest(serializedRequestUint8Array: Uint8Array): Promise<any> {
        const headers: Record<string, string> = {
            'Content-Type': 'application/x-protobuf',
            'X-Goog-Api-Key': LENS_API_KEY,
            'User-Agent': this.#config.userAgent,
            'Accept': '*/*',
            'Accept-Encoding': 'gzip, deflate, br',
            'Accept-Language': this.#config.targetLanguage
                ? `${this.#config.targetLanguage},en;q=0.9`
                : 'en-US,en;q=0.9',
            ...this.#config.headers
        };
        this.#generateCookieHeader(headers);

        const response = await this._fetch(this.#config.endpoint, {
            method: 'POST',
            headers,
            body: serializedRequestUint8Array as unknown as BodyInit,
            redirect: 'follow',
            ...this.#config.fetchOptions
        });

        this.#setCookies(response.headers.get('set-cookie'));

        if (!response.ok) {
            const errorBodyText = await response.text().catch(() => 'Could not read error body');
            throw new LensError(
                `Lens Protobuf API request failed with status ${response.status}`,
                String(response.status),
                response.headers,
                errorBodyText
            );
        }

        const responseArrayBuffer = await response.arrayBuffer();
        const responseUint8Array = new Uint8Array(responseArrayBuffer);
        return LensOverlayServerResponse.deserializeBinary(responseUint8Array);
    }

    async scanByURL(url: string | URL): Promise<LensResult> {
        const urlString = typeof url === 'string' ? url : url.toString();
        const imageResponse = await this._fetch(urlString);
        if (!imageResponse.ok) {
            throw new Error(`Failed to fetch image from URL: ${urlString}, status: ${imageResponse.status}`);
        }
        const imageBuffer = await imageResponse.arrayBuffer();
        const uint8ImgArray = new Uint8Array(imageBuffer);

        let mime = 'image/jpeg';
        const ext = urlString.split('.').pop()?.toLowerCase() ?? '';
        if (ext && (ext in EXT_TO_MIME)) {
            mime = EXT_TO_MIME[ext as keyof typeof EXT_TO_MIME];
        }

        const dimensions = imageDimensionsFromData(uint8ImgArray);
        if (!dimensions) {
            throw new Error('Could not determine image dimensions from URL.');
        }

        return this.scanByData(uint8ImgArray, mime, [dimensions.width, dimensions.height]);
    }

    async scanByData(uint8Array: Uint8Array, mime: string, originalDimensions?: [number, number]): Promise<LensResult> {
        if (!SUPPORTED_MIMES.includes(mime as SupportedMime) && mime !== 'image/gif') {
            console.warn(`MIME type ${mime} might not be directly supported by the proto API, conversion recommended.`);
        }

        const actualDimensions = imageDimensionsFromData(uint8Array);
        if (!actualDimensions) {
            throw new Error('Could not determine actual image dimensions for proto request.');
        }

        const serializedRequest = this.#createLensProtoRequest(uint8Array, actualDimensions.width, actualDimensions.height);
        const serverResponse = await this.#sendProtoRequest(serializedRequest);

        return this.#parseLensProtoResponse(
            serverResponse,
            originalDimensions ?? [actualDimensions.width, actualDimensions.height]
        );
    }

    #generateCookieHeader(header: Record<string, string>): void {
        if (Object.keys(this.cookies).length > 0) {
            const validCookies = Object.entries(this.cookies).filter(([, cookie]) => !cookie.expires || cookie.expires > Date.now());
            this.cookies = Object.fromEntries(validCookies) as CookieStore;
            if (validCookies.length > 0) {
                header.cookie = validCookies
                    .map(([name, cookie]) => `${name}=${cookie.value}`)
                    .join('; ');
            }
        }
    }

    #setCookies(combinedCookieHeader: string | string[] | null): void {
        if (!combinedCookieHeader) return;
        try {
            const splitCookieHeaders = setCookie.splitCookiesString(combinedCookieHeader);
            const cookies = setCookie.parse(splitCookieHeaders, { decodeValues: false });

            if (cookies.length > 0) {
                for (const cookie of cookies) {
                    if (cookie.name && cookie.value) {
                        const expires = cookie.expires ? new Date(cookie.expires).getTime() : Infinity;
                        const detail: CookieDetail = {
                            name: cookie.name,
                            value: cookie.value,
                            expires,
                            domain: cookie.domain,
                            path: cookie.path
                        };
                        this.cookies[cookie.name] = detail;
                    }
                }
            }
        } catch (error) {
            console.error('Failed to parse or set cookies:', error);
        }
    }

    #parseCookies(): void {
        const cookieHeader = this.#config.headers.cookie;
        if (!cookieHeader) {
            return;
        }

        const parsed = parseCookies(cookieHeader);
        for (const [name, value] of Object.entries(parsed)) {
            this.cookies[name] = {
                name,
                value,
                expires: Infinity
            };
        }
    }
}
